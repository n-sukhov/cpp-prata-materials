	#указатели
Операция взятия адреса переменной обозначается символом &, добавленным к имени переменной. Обычно для отображения адресов используется [шестнадцатеричная нотация](obsidian://open?vault=%D0%A1%2B%2B&file=%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B).
- Указатель хранит адрес значения
- Операция разыменования (косвенное значение) * позволяет получить значение, хранящееся в указанном месте
```cpp
int jumbo = 17;
int * pe = &jumbo; // pe - указатель на значение типа int
int * const pe2 = &jumbo; // pе2 - константный указатель на значение типа int
```
- Объявление указателя должно задавать тип указываемого значения
- При одновременном объявлении нескольких переменных, знак * должен быть помещен возле каждой переменной типа указателя:
```cpp
float *p1, p2, *p3; // p1, p3 - указатели; p2 - float  
```
- Выделение места для данных, на которые ссылается указатель, требует отдельного шага:
>[!Warning] Так нельзя
>```cpp
>long * fellow;
>* fellow = 223323;
>```
- Необходимо всегда инициализировать указатель, чтобы определить точный и правильный адрес, прежде, чем применять к немув операцию разыменования (*)
- Указателю нельзя присвоить целочисленное значение (несоответствие типов). Небходимо выполнить [приведение типа](obsidian://open?vault=%D0%A1%2B%2B&file=%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2):
```cpp
int * pt;
pt = (int *) 0xB8000000;
```
>[!Warning] Так нельзя
>```cpp
>int * pt;
>pt = 0xB8000000;
>```
#### Выделение памяти с помощью операции new
Используется, когда нужно получить доступ к неименованной области памяти.
```cpp
ИмяТипа * ИмяУказателя = new ИмяТипа;
```
Память, выделенная при помощи new, хранит значение в куче (свободном хранилище)
#### Освобождение памяти с помощью операции delete
Позволяет вернуть память (выделенную при помощи new) в пул свободной памяти, когда работа с ней завершена
```cpp
int * ps = new int;
...
delete ps;
```
- Не удаляет сам указатель.
- Нельзя освобождать блок памяти, который уже был освобождён
#### Использование new для создания динамических массивов
Создание массива типа int из 10-ти элементов и его освобождение:
```cpp
int * psome = new int [10];
...
delete [] psome;
```
- delete, вместе с new должен использоваться со скобками или без (иначе поведение неопределено)
- Для массива, созданного при помощи new, нельзя применить операцию sizeof, чтобы узнать количество байт в выделенном блоке
#### Указатели, массивы и арифметика указателей
- Добавление единицы к переменной типа указателя увеличивает её значение на количество байт, составляющих размер типа, на который она указывает
- Значение указателя можно менять, но имя массива является константой
- Применение sizeof к имени массива возвращает размер массива в байтах, но применение данной операции к указателю возвращает размер указателя
##### Адрес массива
```cpp
short tell[20];
```
&tell\[0\] и tell - адрес 2-байтного блока памяти, &tell - адрес 20-байтного блока памяти
```cpp
tell + 1 // добавление 2 к адресу памяти
&tell + 1 // добавление 20 к адресу памяти
```
#### Указатели и строки
#строки
- С объектом cout, как и в большинстве других выражений  C++, имя массива char, указатель на char, строковая константа в кавычках - интерпретируются как адрес первого символа новой строки.
- При вводе строки внутри программы всегда необходимо использовать адрес ранее распределённой памяти. Этот адрес может иметь форму массива либо указателя, инициализированного с помощью операции new.
- Для копирования строки в массив надо применять scrcpy() или strncpy(), а не операцию присваивания.

#### Использование операции new для создания динамических структур
#структуры 
Для доступа к элементам структуры, созданной, при помощи new, необходимо воспользоваться операцией ->:
```cpp
inflatable * ps = new inflatable;
std::cin.get(ps->name, 20);
std::cin >> (*ps).volume; //альтернативный вариант доступа к членам структуры
```
#### Шаблонный класс vector
#vector
Динамический массив:
```cpp
std::vector<ИмяТипа> ИмяМассива(количество_элементов);
```
#### Шаблонный класс array
#array
Статический массив:
```cpp
std::array<ИмяТипа, количество_элементов> ИмяМассива;
```

###### Нулевой указатель
```cpp
str = nullptr; // Нотация нулевого указателя в C++ 11 
```
