#классы #защищенные_методы
**Открытое** порождение производного класса базовым:
```cpp
class BaseClassPlus : pulic BaseClass {
	private:
	...
	public:
	...
};
```
При **открытом** порождении:
- Открытые члены базового класса становятся открытыми членами производного класса
- Закрытые члены базового класса становятся закрытыми членами производного класса, но доступ к ним возможен только через *открытые* и *защищенные* методы базового класса
- Объект производного типа хранит данные члены  базового типа
- Объект производного типа может использовать методы базового типа
Что необходимо добавить производному классу:
- Собственные конструкторы
- При необходимости дополнительные данные-члены и методы
Объект базового класса создается до того момента, как программа войдет в тело конструктора производного класса. Для этого можно использовать список инциализаторов членов:
```cpp
SomeConstr::SomeConstr(unsigned int r, float g, bool fn) : BaseConstr(r, g) {
	b_variable = fn;
}
```
	Если опустисть вызов конструктора базового класса, программа воспользуется конструктором базового класса по умолчанию.

Следует также предусмотреть явный вызов конструктора базового класса:
```cpp
SomeConstr::SomeConstr(BaseConstr & bc, bool fn) : BaseConstr(bc) {
	b_variable = fn;
}
```
	В данном случае выполнится конструктор копирования базового класса.

Уничтожение объектов происходит в обратном порядке их создания.

*Чтобы использовать производный класс, программе необходимо предоставить доступ к объявлению базового класса*

#указатели 
Указатель базового класса может указывать на объект производного класса без явного приведения типа. Аналогично может ссылаться ссылка. Однако, они будут позволять вызывать только методы базового класса.
![[Полиморфное открытое наследование]]
![[Совместимость типов указателей и ссылок]]