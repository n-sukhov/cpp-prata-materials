# Типы данных
```C
#include <stdbool.h> // Для использования bool
```
__stdint.h:__
- - Знаковые типы:
    - `int8_t`
    - `int16_t`
    - `int32_t`
    - `int64_t`
- Беззнаковые типы:
    - `uint8_t`
    - `uint16_t`
    - `uint32_t`
    - `uint64_t`
Помимо вышеперечисленных типов, в заголовочном файле stdint.h также перечислены такие типы, как:
- `int_least8_t`
- `uint_fast32_t`
- `intptr_t`
- `intmax_t`
##### Ввод и вывод с платформонезависимыми типами
- `PRI` или `SCN` (вывод или ввода)
- Формат: `x` (16-ричный), `u` (беззнаковый),  `i` или `d` (знаковый)
- Размер в битах или `PTR` для указателей
Примеры:

```C
#include <inttypes.h>
#include <stdio.h>

void f() {
    int64_t i64 = -10;
    uint64_t u64 = 100;
    printf( "Signed 64-bit integer:   %" PRId64  "\n", i64 );
    printf( "Unsigned 64-bit integer: %" PRIu64  "\n", u64 );
    printf( "Pointer, hexadecimal     %" PRIxPTR "\n", &i64 );

    scanf( "%" SCNd64, &i64 );
    scanf( "%" SCNu64, &u64 );
}
```
__Для индекса в массиве или или размер массива нужно использовать _size_t__

##### Тип ptrdiff_t
Рассмотрим случай функции, работающей с массивами.
2 подхода:
- принимаeт адрес начала массива и адрес сразу после последнего элемента;
- принимаe**Неявное преобразование**: если определить для типа псевдоним с помощью `typedef`, между типом и псевдонимом появляется неявное преобразование в две стороны.т адрес начала массива и его размер (как мы теперь знаем, размер должен иметь тип `size_t`).
Когда мы вычитаем два указателя, тип результата -- это знаковое число `ptrdiff_t`.  Его значение, конечно, определено только тогда, когда указатели ссылаются внутрь одного массива. Кроме того, учтите, что _не любая разность указателей в него умещается._ Легко придумать пример для этого:

- пускай `size_t` и `ptrdiff_t` занимают по 32 бита, т.е. 4 байт. 
- тогда диапазон значений `size_t` от [0;232−1][0;232−1], а диапазон значений ptrdiff_t  [−231;231−1][−231;231−1]
- возьмём размер массива 231+1231+1 , тогда разница указателя на последний элемент и указателя на первый элемент не попадает в диапазон типа ptrdiff_t.
По этой причине мы предпочитаем работать с указателем на начало массива и смещением относительно его начала.

**Неявное преобразование**: если определить для типа псевдоним с помощью `typedef`, между типом и псевдонимом появляется неявное преобразование в две стороны.

**Всегда лучше написать не кратко, но понятно и однозначно:**

```c
long x = (long)a + (long)b + (long)c ;
```
##### void*
```cpp
// По стандарту перед печатью надо приводить указатель явно к типу void*
char x;
char* i = &x;
printf("%p", (void*) &i);
```

Указатель `p` типа `void*` нельзя разадресовать, т.е. обратиться по нему. Мы не знаем, на данные какого типа он указывает, поэтому и тип выражения `*p`  неясен. Необходимо сначала сконвертировать его в другой тип указателя, а потом обратиться по нему:

```cpp
int64_t x = 0;

void* p = &x;

// ошибка
int64_t y = *p; 

// правильно
int64_t y = * ((int64_t*) p);
```
### Константы

Традиционно в C глобальные константы определялись с помощью макропроцессора:

```cpp
#define CONST_NAME 42
```

Во многих случаях лучше определять константы как глобальные неизменяемые переменные; например, потому что они типизированы, а литералы -- нет. В некоторых ситуациях это не сработает -- например, для размеров массивов.
#### Куча (Heap)
Чтобы запросить резервирование блока в куче мы пользуемся функцией  `malloc` из стандартной библиотеки языка C. Она вернёт адрес начала выделенного участка памяти. Например:

```cpp
/* Необходим заголовочный файл malloc.h */
#include <malloc.h>

void g() {
   
   // этот массив выделен в стеке
   int64_t marray[2] = { 10, 20 };

   // память под него освободится автоматически 
} 

void f() {

   // этот массив выделен в куче
   int64_t* marray = malloc( sizeof( int64_t ) * 2 );

   marray[0] = 10;
   marray[1] = 20;

   // память под указатель освободится автоматически
   // память под массив остаётся зарезервированной
}
```
Сигнатура функции `malloc` такая:

```cpp
void* malloc( size_t size );
```

Функция принимает запрос на размер массива в байтах и возвращает указатель на начало выделенного массива. Если выделить память не получилось, то будет возвращён `NULL`.
Нужно освобождать эту память  вручную с помощью функции`free` . 

```cpp
void free( void* ptr );
```

Существуют также функции `calloc` и `realloc`

- `realloc` пытается выделить блок другого размера, скопировать туда содержимое старого блока (сколько получится) и деаллоцировать старый. Если выделить новый блок не получилось, старый не будет деаллоцирован.

```arduino
void *realloc(void *ptr, size_t size);
```

- `calloc` выделяет память как `malloc`, но также записывает в неё нули. Размер выделенной памяти -- произведение размера элемента `size` и количества элементов `nmemb`.

```arduino
void *calloc(size_t nmemb, size_t size);
```

Имейте в виду, что запись нулей в память не всегда означает запись туда нулевых значений. К примеру, указатель в никуда `NULL`  на некоторых архитектурах может кодироваться числом, в котором, наоборот, все биты равны единицам. Или число с плавающей точкой 0.0 типа `double` может представляться иначе, чем 8-байтовым числом, в котором все биты равны нулям. Поэтому обнуление памяти с помощью  `calloc` (или, например, функции `memset`)  в общем случае _не означает корректной инициализации данных нулевыми значениями._

В отличие от массива, где все элементы лежат в памяти последовательно без пропусков, в структурах между полями могут быть отступы. На современных компьютерах зачастую чтение из памяти происходит быстрее по адресам кратным 4 или 8, поэтому если поле структуры занимает, скажем, 3 байта, компилятор может отступить один байт до следующего поля, заполнив его мусором.

```cpp
struct test {       // Минимум один байт пропадёт
   char first[3];   // X X X _
   int64_t second;  // X X X X 
                    // X X X X
};
```

**Поэтому размер структуры может быть больше, чем сумма размеров её элементов. Если вы напишете в этом примере 7 вместо sizeof(struct test), то ошибётесь! Никогда не заменяйте корректное выражение `sizeof(struct S)` на посчитанный вручную размер `struct S`!**
## Кодирование связного списка

Пару из значения и адреса следующего элемента можно закодировать так: 

```cpp
// list это тип элементов списка

struct list {
   int64_t value;
   struct list* next;
};
```

Список задаётся указателем на его первый элемент. Если список пустой, то этот указатель устанавливается в NULL.

```cpp
struct list* mylist = NULL ; // этот список пустой
```

Непустой список задаётся ненулевым указателем на первый элемент. Вернёмся к списку (1, 2, 3):

![](https://ucarecdn.com/f0da9cd7-ba06-4508-a7e7-9ec38438ac68/)

В коде его можно представить так: 

```cpp
struct list {
   int64_t value;
   struct list* next;
};

...

struct list x3 = { 3, NULL };
struct list x2 = { 2, &x3 };
struct list x1 = { 1, &x2 };

struct list* mylist = &x1; // это список (1,2,3)

```

Началом списка будет являться указатель `mylist` на `x1`.

## **Пространства имён**

Можно объявить тип-структуру struct T и псевдоним для какого-то типа T; это не приведёт к конфликту имён типов.

```cpp
struct T { int64_t value; } ; 
typedef int64_t T;
// конфликта нет
```

Однако имена структур и объединений находятся в одном пространстве имён: определив структурный тип struct T мы уже не сможем определить тип-объединение union T (и наоборот).

```cpp
struct T { int64_t value; } ; 
union  T { int64_t value; } ; // конфликт со struct T
```
## Применение перечислений

1. Один из способов задать именованную константу без `#define` -- использовать анонимное перечисление.
    
    ```cpp
    enum { A = 320 };
    
    // можно создавать массив такой длины!
    char array1[A] = {0};
    
    
    // а массив длины, взятой из глобальной неизменяемой переменной, сделать нельзя: 
    const int B = 320;
    char array2[B] = {0}; // ошибка компиляции
    ```
    
2. Если сущность в программе может быть в одном из небольшого фиксированного количества состояний, то удобно применять перечисление для описания текущего состояния. Например, если мы реализуем [конечный автомат](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82).
3. Предположим, функция копирует файл из одного места в другое. Операция может завершиться успехом или может произойти одна из многочисленных ошибок:
    
    - не хватает прав для записи,
    - мало места на диске,
    - ошибка чтения из файла и т.д.
    
    Можно написать функцию копирования так:
    
    ```cpp
    bool copy_file( const char* from, const char* to ) {
    
    ...
    пытаемся скопировать файл
    ...
    
    if (на диске не хватает места)  {
      printf("Не хватает места");
      return false;
    }
    
    if (ошибка чтения)  {
      printf("Ошибка чтения с диска");
      return false;
    }
    
    return true;
    
    }
    ```
    
    В этом коде есть две проблемы:
    
    1. вызывающая `copy_file` функция не может знать, что именно произошло в ней не так. Она может знать только получилось скопировать или нет.
        
    2. логика "скопировать файл" смешивается тут с логикой "вывести сообщение об ошибке". А если программа локализуется на несколько языков, как быть с вкодированными прямо сюда сообщениями об ошибках? Переписывать функцию копирования файла (а потом её заново тестировать и т.д.?)  
         
        
    
    Можно разделить логику функции `copy_file` на три части: основные действия и выдача ошибок; выбор соответствия ошибок и сообщений об ошибке; показ сообщений.
    
    ```cpp
    enum copy_file_result {
       CF_OK, 
       CF_ERROR_OUT_OF_SPACE,
       CF_ERROR_IO
    };
    
    enum copy_file_result 
    copy_file( const char* from, const char* to ) {
    
    ...
    пытаемся скопировать файл
    ...
    
    if (на диске не хватает места)  {
      return CF_ERROR_OUT_OF_SPACE;
    }
    
    if (ошибка чтения)  {
      return CF_ERROR_IO;
    }
    
    return CF_OK;
    }
    
    const char* const cf_error_messages[] = {
    [CF_ERROR_OUT_OF_SPACE] = "Не хватает места",
    [CF_ERROR_IO] = "Ошибка чтения с диска"
    };
    
    
    void perform_copy_file(const char* from, const char* to) {
      enum copy_file_result status = copy_file(from, to);
      printf( cf_error_messages[status] );
    }
    ```
    
    Так можно легко  модицифировать программу для поддержки разных языков, сделать графическое приложение (в котором `printf` не используется для показа сообщений пользователю); функции остаются маленькими, и логика обработки ошибок может быть сконцентрирована в одном месте, а не смешиваться с логикой копирования файла.
## Типы это информация о возможных данных

В прошлом задании у нас возникла щекотливая ситуация. Предположим, что `either_int_string` хранит указатель на строку. При этом строка занимает место в памяти _где-то ещё,_ и эту память, возможно, необходимо освобождать вручную с помощью `free`.

Вспомним, где вообще могут храниться строки:

- Если строка в стеке, то это локальная переменная какой-то функции `f` и она сама уничтожится при выходе из `f`.
    
    ```cpp
    void f() {
      char string[] = "hello";
    }
    ```
    
      
    Экземпляр `either_int_string` тогда не должен жить дольше, чем `f` , например, копироваться в ту функцию, которая вызывает `f`. Иначе в нём останется указатель на память, которая при выходе из `f` освобождалась.   
    Вряд ли мы хотели бы внутри `either_int_string` хранить указатель на строку в стеке.
- Если строка в глобальной области данных, то это глобальная переменная или строковый литерал:
    
    ```cpp
    // Глобальные изменяемые данные
    char[] hello = "hello";
    
    
    
    void f(char*); 
    
    void g() {
       // Здесь создаётся блок глобальных неизменяемых данных,
       // в котором хранится строка Hi; 
       // указатель на него передаётся в функцию f.
       f("Hi"); 
    }
    ```
    
    Глобальные переменные живут вплоть до завершения программы, и освобождать их вручную не нужно.
    
- Если строка размещена в куче, память для неё выделяется с помощью `malloc`, и должна быть освобождена вручную вызовом `free`. 

Нам бы помогло, если бы мы могли различать указатели на _строки в куче_ и указатели на _остальные строки_. Так будет ясно, следует ли вызывать `free` для неё когда-нибудь, или нет. **В идеале при попытке использовать один указатель вместо другого компилятор должен выдать нам ошибку**. Есть несколько способов создать новый тип, но не все нам подходят.

1. Создать псевдоним для типа `char*` с помощью `typedef`.
    
    ```cpp
    typedef char* heap_string;
    ```
    
    Как вы помните, при создании псевдонима в программе появляются неявные преобразования в две стороны: вместо `char*` теперь можно использовать `heap_string`, и наоборот. Но хотя бы типы в сигнатурах функций и в полях структур теперь могут нести больше информации:
    
    ```cpp
    void print_and_deallocate( heap_string s ) {
      ...
    }
    ```
    
    К сожалению, конверсии как раз дело и портят: компилятор **не запрещает** нам передавать вместо `heap_string` любые данные типа `char*`, хотя наша цель была **предотвратить** такую ситуацию.
2. Сделать структуру из одного поля, в которую упаковать указатель. 
    
    ```cpp
    struct heap_string {
       char* addr;
    };
    
    void print_and_deallocate( struct heap_string s ) {
      ...
    }
    ```
    
      
    Теперь мы не можем передавать в функцию `print_and_deallocate` произвольные строчки -- только те, что были явно упакованы в структуру `heap_string`. С точки зрения производительности структура `heap_string` и её поле `addr` полностью эквивалентны и по потреблению памяти, и по тому, как с ними будет производиться работа на уровне машинных инструкций, поэтому не бойтесь создавать столько структурных типов, сколько необходимо.

## Типобезопасные псевдонимы с помощью typedef

В случае, когда новый тип является просто обёрткой над старым, автор курса считает _допустимым_ использовать `typedef` совместно с объявлением структурного типа, вот так:

```cpp
typedef struct  {
   char* addr;
} heap_string;
// heap_string это псевдоним для анонимного структурного типа struct { char* addr }
// так мы не создаём структурного типа с именем и можем использовать heap_string без ключевого слова struct
// Здесь struct используется как хак для создания псевдонима типа без добавления неявных конверсий
// и никак не означает, что внутри неё -- большая структура данных. 

void print_and_deallocate( heap_string s ) {
  printf(s.addr);
  free( s.addr );
}
```

Так можно помечать данные и другой информацией. Например, пользователь вводит любое число, но программа ожидает число от 5 до 7. После проверки можно упаковать число в структуру:

```cpp
typedef struct {
   int64_t value;
} sanitized_int;

sanitized_int sanitize( int64_t i ) {
  if (5 <= i && i <= 7 ) {
     return (sanitized_int) { .value = i };
  } 
  else { 
    // аварийное завершение, но можно сделать разумную обработку ошибки 
    abort(); 
  } 
}


void do_something( sanitized_int i ) {
  // В этом месте кода есть гарантия, что 5 <= i.value <= 7
  // произвольное число без упаковки мы передать в i не можем

}
```

Еще несколько применений для упакованных по-разному данных одного типа:

- Идентификаторы разных сущностей в программе часто являются целыми числами: ID процесса, файловые дескрипторы и т.д. С помощью структур их можно различать чтобы не передавать в функцию, ожидающую файловый дескриптор, длину в метрах.
- Метры, килограммы, литры, км/ч -- нельзя, скажем, складывать величины разной размерности, хотя все они выражаются числами.

## Типы функций

Функции в C тоже имеют типы, как и более привычные нам данные. Тип функции это её сигнатура: комбинация типов параметров и типа возвращаемого значения. Описываются такие типы не очень привычно:

```cpp
// ftype -- тип функции, возвращающей int, принимающей два аргумента
// типов const char* и float
typedef int ftype(const char*, float);
```

Описание функционального типа очень похоже на объявление функции. Сравните:

```cpp
// Тип функции ftype

typedef int   ftype   (const char*, float);

// Объявление функции myfunction с такой же сигнатурой 
// Можно сказать, что её тип совместим с ftype

        int myfunction(const char*, float);
```

Псевдоним типа функции можно использовать для объявлений функций с такой сигнатурой. Синтаксически это похоже на объявление переменных:

```cpp
typedef void action(const char*);

action print;
action log;
action send;

// то же самое, что и:

void print(const char*);
void log(const char*);
void send(const char*);
```

К сожалению, функциональные типы в C пишутся достаточно громоздко и их тяжело читать. Для удобства мы будем использовать нотацию со стрелочкой, вот так:

- `void -> void`  
    Функция, ничего не принимающая и не возвращающая
- `(int64_t, int64_t) -> void`  
    Функция, принимающая два числа типа `int64_t` и ничего не возвращающая
- `const int64_t* -> float`  
    Функция, принимающая один аргумент типа `const int64_t*` и возвращающая `float`. 

Чаще всего функциональные типы используются чтобы создавать указатели на функции.

## Применение: функции высшего порядка

Указатели на функции это мощный инструмент написания краткого и выразительного кода.

Вернёмся к примеру с применением двух разных функций к каждому элементу массива. Можно думать об этом коде так: каждый элемент массива мы возводим в квадрат и удваиваем. Другими словами, мы хотим уметь "к каждому элементу массива применить какую-то трансформацию", при этом трансформация может быть "возвести в квадрат" или "удвоить".  Мы абстрагируемся от того, какая именно это будет трансформация; каждый раз она может быть разной. Чтобы минимизировать количество кода:

- Опишем логику применения произвольной трансформации _T_ к каждому элементу массива как отдельную функцию `map`; _T_ будет её параметром.
- Оформим каждую интересующую нас трансформацию в виде отдельной функции
- Для применения трансформации к каждому элементу массива передадим в map адрес функции, реализующей её.

```cpp
int64_t square( int64_t x ) { return x * x; }
int64_t cube  ( int64_t x ) { return x * x * x; }


// Параметр-указатель на функцию можно писать без звёздочки
void map( int64_t* array, size_t count, int64_t T(int64_t) ) {
  for( size_t i = 0; i < count; i = i + 1 ) {
      array[i] = T( array[i] );
   }
}

int main() {

   int64_t array[] = { 1, 2, 3, 4, 5 };

   const size_t count = sizeof(array) / sizeof(array[0]);
 
   map( array, count, square );
   map( array, count, cube );

   return 0;
}
```
## Преобразования указателей на функции

### void* и указатели на функции

> **Внимание** по стандарту языка нельзя использовать указатели на данные как указатели на функции, и наоборот.

Мы уже знаем про тип `void*` , который обозначает "указатель на что угодно". По стандарту языка C это "что угодно" может быть _только типом объекта_. Здесь _объект_ понимается **не в смысле объектно-ориентированного программирования** -- стандарт называет объектом любые данные, которая хранится в памяти абстрактного вычислителя: числа, объединения, строчки, структуры и перечисления, массивы... но не функции. Поэтому тип`void*` по стандарту нельзя преобразовывать в тип указателя на функцию и наоборот.  

Типы указателей на функции, однако, можно преобразовывать друг к другу. При этом сколько бы мы между ними не делали конвертаций, если в конце привести тип указателя так, чтобы он соответствовал сигнатуре функции, на которую он указывает, то мы сможем корректно вызвать эту функцию по указателю.

```cpp
char f(char x) { return 'a' + x; }

...
char (*p1)(char) = f;

// преобразуем в const int64_t* -> void
// обязательно явно конвертировать
void (*p2)(const int64_t*) = (void (*)(const int64_t*))(p1);
//                           |________________________|  в этот тип мы преобразуем p1
// это тип указателя на функцию, которая принимает const int64_t* и ничего не возвращает

// преобразуем обратно в char -> char
char (*p3)(char)  = (char (*)(char))(p2);


// вызовем f через p2
p3(2);  // корректно т.к. тип p3 соответствует типу f, вернёт 'c'

...
```

Если же это преобразование обратно не сделать, то не гарантируется, что вызов будет совершён правильно.

```cpp
void  f(void* x)  { }

...
void (*p1)(void*) = f;

void (*p2)(int64_t*) = (void (*)(int64_t*))(p1);


p2( NULL );  // некорректно!
             // тип f: void* -> void
             // p2 указывает на: int64_t* -> void
```

Мы увидим важность этого на следующем слайде когда поговорим про функцию `qsort` и обобщённые сортировки. 

[1] Однако стандарт [POSIX](https://ru.wikipedia.org/wiki/POSIX) требует, чтобы указатели на функции можно было записывать в `void*` а затем преобразовывать обратно.