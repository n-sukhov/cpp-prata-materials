#перечисления
```cpp
enum spectrum { red, orange, yellow, green, blue, violet, indigo, ultraviolet };
// spectrum - перечисление; red, orange и т.д. - перечислители
spectrum band; // band - переменная типа spectrum
```
- Устанавливает перечислители в качестве символических констант для целочисленных значений, начиная с 0, каждое последующее больше предыдущего на 1.
- Единственными допустимыми значениями, которые можно присвоить переменной данного типа без необходимости приведения типов, - значения, указанные в определении этого перечисления:
```cpp
band = blue;
```
>[!Warning] Так нельзя
>```cpp
>band = 4;
>```
- Для перечислителей определена только операция присваивания
- Могут быть представлены в виде int (int не преобразуется автоматически в тип перечисления):
```cpp
band = spectrum(3);
```
>[!Warning] Так нельзя
>```cpp
>band = spectrum(300); // результат не определён
>```
- Можно явно устанавливать значения перечислителей:
```cpp
enum bits {  zero, null = 0, two = 2, three, seven = 7, last };
```
- В поздних версиях C++ элементам перечислений можно присваивать значения типа long или long long
- Перечислению можно присваивать любое значение из его диапазона (верхний предел - наименьшее число, являющееся степенью двойки, которое больше максимального значение перечислителя, из него вычитается единица; нижний предел - если перечислитель с минимальным значением больше или равен 0 -> 0, если меньше 0 -> такой же алгоритм, как для нахождения верхнего предела, но со знаком "-")
```cpp
bits myflag;
myflag = bits(6);
```
#### Перечисления с областью видимости класса
#классы
Избежать конфликта имен в перечислениях можно за счёт указания для перечислителей области видимости класса:
```cpp
enum class egg {S, M, L};
enum class t_shirt {S, M, L};
```
	Вместо class можно использовать struct
```cpp
egg choice = egg::L;
t_shirt Floyd = t_shirt::L;
```
>[!Warning]
>Перечисления с областью видимости класса не поддерживают неявных преобразований в целочисленные типы
>```cpp
>enum egg {S, M, L};
>enum class t_shirt {S, M, L};
>egg one = M;
>t_short rolf = t_shirt::L;
>int king = one; // разрешено
>int ring = rolf; // не разрешено
>int f = int(t_shirt::S); // при необходимости можно выполнить явное преобразование типа
>```

Синтаксис для указания другого лежащего в основе типа:
```cpp
enum class : short pizza {S, M, L};
```