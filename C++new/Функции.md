Для использования функции необходимо:
- Определить функцию
- Предоставить прототип функции
- Вызвать функцию
Чтобы пользоваться библиотечной функцией, необходимо использовать библиотечный заголовочный файл.
### Определение функции
Функция, не возвращающая параметры:
```cpp
void functionName(parameters):
{
	operators;
	return; // не обязательно
}
```
- Список параметров указывает типы и количество аргументов, передаваемых функции
- return отмечает конец функции
Функция, возвращающая значение:
```cpp
typeName functionName(parameters)
{
	operators;
	return value; // value приводится к typeName
}
```
- Если функция содержит более одного оператора return, она завершается по достижении первого
### Прототипирование и вызов функции
- Прототип должен находиться перед функцией main
- Прототип совпадает с заголовком функции:
	- В прототипе можно не указывать имена переменных-параметров
	- В прототипе можно указывать отличные от определения функции имена переменных-параметров
```cpp
void functionName(parameters);
typeName functionName1(parameters);
```
- Пустые скобки или указание ключевого слова void между ними значит, что функция не принимает аргументов
- Указание ... между скобками означает отсутствие списка аргументов
	- Обычно такое применение многоточия необходимо только для взаимодействия с такими функциями C, как printf(), которые имеют переменное количество аргументов

##### Аргументы функций и передача по значению
- При передаче числового значения аргумента в функцию оно присваивается новой переменной
Переменная, используемая для приёма переданного значения, называется _формальным параметром_ (_параметром_)
	Значение, переданное функции, называется _фактическим аргументом_ (_аргументом _)
- Переменные, включая параметры, объявленные в функции, являются приватными по отношению к этой функции. Это локальные переменные.
- Переменные, объявленные внутри функции, называюстя автоматическими переменными
##### Множественные аргументы
- Функция может принимать более одного аргумента, при её вызове такие аргументы отделяются запятыми
- Если функция имеет несколько параметров одного и того же типа, типы каждого параметра должны указываться по отдельности
### Функции и массивы
Способы передачи массива в функцию:
```cpp
int function(int *arr);
int function1(int arr[]);
```
Функция интерпретирует имя массива, как адрес первого элемента. Оба варианта _int function\[]_ и _int *fuction_ только тогда, когда применяются в заголовке или прототипе функции.
- При передаче массива в функция, она работает с оригиналом массива, а не его копией
- Нельзя передавать размер массива функции в нотации квадратных скобок, информация передаётся в отдельном аргументе (либо использовать диапазон массивов, передавая указатель на первый элемент и на следующий за последним)

Если функция не должна вносить изменения в массив, его можно защитить посредством _const_, тогда функция не сможет изменять массив:
```cpp
void function(const double[] arr, int n);
```
##### Указатели и _const_
#указатели 
Объявим указатель на константу:
```cpp
ing a = 17;
const int *pt = &a;
```
- Само значени _a_ не обязательно должно быть константным, но его нельзя изменить именно через указатель _pt_\
- Присваивать адрес константной переменной неконстантному укзателю нельзя
>[!Warning]
>Можно присваивать адрес как константных, так и не константных данных указателю на константу, предполагая, что эти данные сами не являются  указателем, но  присвоить адрес не константных данных допускается только не константному указателю

Объявление константного указателя:
```cpp
int a = 7;
int b = 11;
int * const pt = &a; // нельзя менять переменную, на которую указывает pt: pt = &b
```
- Применение _const_ в этом объявлении означает, что функция не может изменять значения в переданном ей массиве. Этот приём работает до тех пор, пока есть только один уровень косвенности. Здесь элементы массива относятся к базовому типу, но если бы они были указателями или указателями на указатели, использовать _const_ не удалось бы.
```cpp 
void function(const double arr[], int n);
```
###### Функции и двумерные массивы
Объявление функции, принимающей двумерный массив:
```cpp
int function(double (*arr)[7], int size); // 1-й вариант
int function(double arr[][7], int size);// 2-й вариант
```
Дла получения данных из двумерного массива необходимо дважды разыменовать указатель или использовать нотацию с квадратными скобками:
```cpp
arr[r][c] == *(*(ar + r) + c) // одно и то же
```
###### Функции с аргументами-строками в стиле C
Поскольку строка содержит нулевой символ, нужно передавать в функцию не размер строки. Можно использовать цикл для поочерёдного обхода символов строки.
##### Функции и структуры
Передача структуры в функцию по значению имеет смысл, когда структура компактна, по адресу в случае, если структура большая.
###### Функции и объекты
Объекты в функцию, как и структуры, можно передавать, как единую сущность.
![[Рекурсия]]
##### Указатели на функции
- Чтобы получить адрес функции, надо использовать её имя без скобок
	```cpp
	function() // вызов функции
	function // адрес функии
```
Объявление указателя на функцию:
	В общем случае для объявления уазателя на функцию определённого рода можно сначала написать прототип обычной функции требуемого вида, а затем заменить её имя выражением в форме (\*pf), где pf - указатель на функцию этого типа.
```cpp
double pam(int); // прототип
double (*pf) (int); // указатель на функцию
double *pf(int) // pf() - функция, возвращающая указатель на double
```
- Использование указателя для вызова функции
```cpp
double pam(int);
double (*pf) (int);
pf = pam;
double x = pam(4); // вызывает pam(), используя её имя
double y = (*pf)(5); // вызывает pam(), используя указатель pf
```
	C++ позволяет использовать pf, как если бы это было имя функции:
```cpp
double y = pf(5);
```
### Вариации на тему указателей на функции
См. C++ С. Прата страница 360


![[Псевдонимы типов]]
![[Дополнительные сведения о функциях]]
