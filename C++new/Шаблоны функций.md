```cpp
template <typename AnyType> void Swap(AnyType &a, Anytype &b) {
	AnyType temp;
	temp = a;
	a = b;
	b = temp;
}
```
- template, typename - ключевые слова, AnyType - выбранное имя для произвольного типа данных
- Вместо typename можно использовать class
- Чтобы сообщить компилятору о том, что нужна определённая форма функции, в программе достаточно вызвать данную функцию. Компилятор сгенерирует функцию в соответствие с типами передаваемых аргументов
- _template \<typename ...\>_ необходимо ставить перед прототипом и перед объявлением функции
- Не все аргументы шаблонов должны обязательно иметь обобщённый тип
- Шаблоны можно перегружать, как обычные функции
### Явные специализации
- Одно и то же имя может применяться для нешаблонной функции, шаблонной функции и явной специализации шаблона, а так же для всех перегруженных версий всего перечисленного
- Прототип и определение явной специализации должно быть предварено _template <>_, а также указывать на имя обобщённого типа данных
- Специализация переопределяет обычный шаблон, а нешаблонная функция переопределяет и специализацию и шаблон
Явная специлизация:
```cpp
template <> void function<char>(char &, char &); //конструкция <char> необязательна
```
##### Создание экземпляров
- Неявное создание экземпляров - когда компилятор генерирует определение функции на основе шаблона в результате её вызова
- Явное создание экземпляров:
```cpp
  template void Swap<int>(int &, int &);
```
>[!Warning]
>Нельзя применять в одном компилируемом модуле явную специализацию и явное создание экземпляра одного и того же типа

Явное создание экземпляров за счёт использование функции в программе:
```cpp
template <class T> T Add(T a, T b) {
	return a + b;
}
...
int m = 7;
double x = 10.3;
cout << Add<double>(m, x);
```
###### Разрешение перегрузки
Порядок следования от наилучшего к наихудшему:
1. Точное соответствие, при этом обычные функции имеют приоритет перед шаблонами.
2. Преобразование за счёт расширения (например, автоматические преобразования char и short в int и float в double).
3. Преобразование с помощью стандартных преобразований.
4. Преобразования, определяемые пользователем, такие как те, что определены в объявлениях классов.
Наличие угловых скобок указывает, что компилятор должен вызвать шаблонную функцию вместо нешаблонной:
```cpp
cout << function<>(m, n) << endl;
```
![[Ключевое слово decltype (C++11)]]
![[Хвостовой возвращаемый тип C++11]]